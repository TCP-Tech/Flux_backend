// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: submissions.sql

package database

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
)

const canSubmitProblemInPractice = `-- name: CanSubmitProblemInPractice :one
SELECT COALESCE(
    max_end_time IS NULL OR
    now() > max_end_time
)::BOOLEAN
FROM (
    SELECT max(c.end_time) AS max_end_time
    FROM problems p
    JOIN contest_problems cp ON p.id = cp.problem_id
    JOIN contests c ON c.id = cp.contest_id
    WHERE problem_id = $1 AND c.lock_id IS NOT NULL
) AS t
`

func (q *Queries) CanSubmitProblemInPractice(ctx context.Context, problemID int32) (bool, error) {
	row := q.db.QueryRow(ctx, canSubmitProblemInPractice, problemID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const insertSubmission = `-- name: InsertSubmission :one
INSERT INTO submissions (
    submitted_by,
    contest_id,
    problem_id,
    solution,
    state
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
RETURNING id, submitted_by, contest_id, problem_id, solution, state, submitted_at, updated_at
`

type InsertSubmissionParams struct {
	SubmittedBy uuid.UUID       `json:"submitted_by"`
	ContestID   *uuid.UUID      `json:"contest_id"`
	ProblemID   int32           `json:"problem_id"`
	Solution    json.RawMessage `json:"solution"`
	State       string          `json:"state"`
}

func (q *Queries) InsertSubmission(ctx context.Context, arg InsertSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, insertSubmission,
		arg.SubmittedBy,
		arg.ContestID,
		arg.ProblemID,
		arg.Solution,
		arg.State,
	)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.SubmittedBy,
		&i.ContestID,
		&i.ProblemID,
		&i.Solution,
		&i.State,
		&i.SubmittedAt,
		&i.UpdatedAt,
	)
	return i, err
}
