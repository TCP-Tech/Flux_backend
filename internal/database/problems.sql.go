// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: problems.sql

package database

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const addProblem = `-- name: AddProblem :one
INSERT INTO problems (
    title,
    difficulty,
    evaluator,
    lock_id,
    created_by,
    last_updated_by
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, title, difficulty, evaluator, lock_id, created_by, last_updated_by, created_at, updated_at
`

type AddProblemParams struct {
	Title         string     `json:"title"`
	Difficulty    int32      `json:"difficulty"`
	Evaluator     string     `json:"evaluator"`
	LockID        *uuid.UUID `json:"lock_id"`
	CreatedBy     uuid.UUID  `json:"created_by"`
	LastUpdatedBy uuid.UUID  `json:"last_updated_by"`
}

func (q *Queries) AddProblem(ctx context.Context, arg AddProblemParams) (Problem, error) {
	row := q.db.QueryRow(ctx, addProblem,
		arg.Title,
		arg.Difficulty,
		arg.Evaluator,
		arg.LockID,
		arg.CreatedBy,
		arg.LastUpdatedBy,
	)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Difficulty,
		&i.Evaluator,
		&i.LockID,
		&i.CreatedBy,
		&i.LastUpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const addStandardProblemData = `-- name: AddStandardProblemData :one
INSERT INTO standard_problem_data (
    problem_id,
    statement,
    input_format,
    output_format,
    function_definitons,
    example_testcases,
    notes,
    memory_limit_kb,
    time_limit_ms,
    submission_link,
    last_updated_by
) VALUES (
    $1,  -- problem_id
    $2,  -- statement
    $3,  -- input_format
    $4,  -- output_format
    $5,  -- function_definiton
    $6,  -- example_testcases
    $7,  -- notes
    $8,  -- memory_limit_kb
    $9,  -- time_limit_ms
    $10,  -- submission_link
    $11  -- last_)updated_by
)
RETURNING problem_id, statement, input_format, output_format, function_definitons, example_testcases, notes, memory_limit_kb, time_limit_ms, submission_link, last_updated_by
`

type AddStandardProblemDataParams struct {
	ProblemID          int32            `json:"problem_id"`
	Statement          string           `json:"statement"`
	InputFormat        string           `json:"input_format"`
	OutputFormat       string           `json:"output_format"`
	FunctionDefinitons *json.RawMessage `json:"function_definitons"`
	ExampleTestcases   *json.RawMessage `json:"example_testcases"`
	Notes              *string          `json:"notes"`
	MemoryLimitKb      int32            `json:"memory_limit_kb"`
	TimeLimitMs        int32            `json:"time_limit_ms"`
	SubmissionLink     *string          `json:"submission_link"`
	LastUpdatedBy      uuid.UUID        `json:"last_updated_by"`
}

func (q *Queries) AddStandardProblemData(ctx context.Context, arg AddStandardProblemDataParams) (StandardProblemDatum, error) {
	row := q.db.QueryRow(ctx, addStandardProblemData,
		arg.ProblemID,
		arg.Statement,
		arg.InputFormat,
		arg.OutputFormat,
		arg.FunctionDefinitons,
		arg.ExampleTestcases,
		arg.Notes,
		arg.MemoryLimitKb,
		arg.TimeLimitMs,
		arg.SubmissionLink,
		arg.LastUpdatedBy,
	)
	var i StandardProblemDatum
	err := row.Scan(
		&i.ProblemID,
		&i.Statement,
		&i.InputFormat,
		&i.OutputFormat,
		&i.FunctionDefinitons,
		&i.ExampleTestcases,
		&i.Notes,
		&i.MemoryLimitKb,
		&i.TimeLimitMs,
		&i.SubmissionLink,
		&i.LastUpdatedBy,
	)
	return i, err
}

const checkPlatformType = `-- name: CheckPlatformType :one
SELECT $1::Platform
`

func (q *Queries) CheckPlatformType(ctx context.Context, dollar_1 interface{}) (interface{}, error) {
	row := q.db.QueryRow(ctx, checkPlatformType, dollar_1)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const getProblemByID = `-- name: GetProblemByID :one
SELECT 
    p.id,
    p.title,
    p.difficulty,
    p.evaluator,
    p.lock_id,
    p.created_by,

    l.access,
    l.timeout
FROM
    problems p
LEFT JOIN
    locks l
ON
    p.lock_id = l.id
WHERE p.id=$1
`

type GetProblemByIDRow struct {
	ID         int32      `json:"id"`
	Title      string     `json:"title"`
	Difficulty int32      `json:"difficulty"`
	Evaluator  string     `json:"evaluator"`
	LockID     *uuid.UUID `json:"lock_id"`
	CreatedBy  uuid.UUID  `json:"created_by"`
	Access     *string    `json:"access"`
	Timeout    *time.Time `json:"timeout"`
}

func (q *Queries) GetProblemByID(ctx context.Context, id int32) (GetProblemByIDRow, error) {
	row := q.db.QueryRow(ctx, getProblemByID, id)
	var i GetProblemByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Difficulty,
		&i.Evaluator,
		&i.LockID,
		&i.CreatedBy,
		&i.Access,
		&i.Timeout,
	)
	return i, err
}

const getProblemsByFilters = `-- name: GetProblemsByFilters :many
SELECT
    p.id,
    p.title,
    p.difficulty,
    p.evaluator,
    p.created_by,
    p.lock_id,

    l.timeout,
    l.access
FROM
    problems AS p
JOIN 
    standard_problem_data AS pd
ON
    p.id = pd.problem_id
LEFT JOIN
    locks AS l ON p.lock_id = l.id
WHERE
    -- Optional filter by a list of problem IDs
    (
        ($1::int[]) IS NULL OR
        cardinality($1::int[]) = 0 OR
        p.id = ANY($1::int[])
    )
AND
    -- Optional filter by lock_id
    (
        $2::uuid IS NULL OR
        p.lock_id = $2::uuid
    )
AND
    -- Optional filter by creator
    (
        $3::uuid IS NULL OR
        p.created_by = $3::uuid
    )
AND
    -- Optional filter by evaluator
    (
        $4::text IS NULL OR
        p.evaluator = $4::text
    )
AND
    (
        -- Title search with wildcards handled in SQL
        $5::text IS NULL OR
        p.title ILIKE '%' || $5::text || '%'    
    )
ORDER BY
    p.created_at DESC
LIMIT
    $7
OFFSET
    $6
`

type GetProblemsByFiltersParams struct {
	ProblemIds  []int32    `json:"problem_ids"`
	LockID      *uuid.UUID `json:"lock_id"`
	CreatedBy   *uuid.UUID `json:"created_by"`
	Evaluator   *string    `json:"evaluator"`
	TitleSearch *string    `json:"title_search"`
	Offset      int32      `json:"offset"`
	Limit       int32      `json:"limit"`
}

type GetProblemsByFiltersRow struct {
	ID         int32      `json:"id"`
	Title      string     `json:"title"`
	Difficulty int32      `json:"difficulty"`
	Evaluator  string     `json:"evaluator"`
	CreatedBy  uuid.UUID  `json:"created_by"`
	LockID     *uuid.UUID `json:"lock_id"`
	Timeout    *time.Time `json:"timeout"`
	Access     *string    `json:"access"`
}

func (q *Queries) GetProblemsByFilters(ctx context.Context, arg GetProblemsByFiltersParams) ([]GetProblemsByFiltersRow, error) {
	rows, err := q.db.Query(ctx, getProblemsByFilters,
		arg.ProblemIds,
		arg.LockID,
		arg.CreatedBy,
		arg.Evaluator,
		arg.TitleSearch,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProblemsByFiltersRow
	for rows.Next() {
		var i GetProblemsByFiltersRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Difficulty,
			&i.Evaluator,
			&i.CreatedBy,
			&i.LockID,
			&i.Timeout,
			&i.Access,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStandardProblemData = `-- name: GetStandardProblemData :one
SELECT problem_id, statement, input_format, output_format, function_definitons, example_testcases, notes, memory_limit_kb, time_limit_ms, submission_link, last_updated_by FROM standard_problem_data WHERE problem_id=$1
`

func (q *Queries) GetStandardProblemData(ctx context.Context, problemID int32) (StandardProblemDatum, error) {
	row := q.db.QueryRow(ctx, getStandardProblemData, problemID)
	var i StandardProblemDatum
	err := row.Scan(
		&i.ProblemID,
		&i.Statement,
		&i.InputFormat,
		&i.OutputFormat,
		&i.FunctionDefinitons,
		&i.ExampleTestcases,
		&i.Notes,
		&i.MemoryLimitKb,
		&i.TimeLimitMs,
		&i.SubmissionLink,
		&i.LastUpdatedBy,
	)
	return i, err
}

const updateProblem = `-- name: UpdateProblem :one
UPDATE problems SET
    title=$2,
    difficulty=$3,
    evaluator=$4,
    lock_id=$5,
    last_updated_by=$6
WHERE 
    id=$1
RETURNING id, title, difficulty, evaluator, lock_id, created_by, last_updated_by, created_at, updated_at
`

type UpdateProblemParams struct {
	ID            int32      `json:"id"`
	Title         string     `json:"title"`
	Difficulty    int32      `json:"difficulty"`
	Evaluator     string     `json:"evaluator"`
	LockID        *uuid.UUID `json:"lock_id"`
	LastUpdatedBy uuid.UUID  `json:"last_updated_by"`
}

func (q *Queries) UpdateProblem(ctx context.Context, arg UpdateProblemParams) (Problem, error) {
	row := q.db.QueryRow(ctx, updateProblem,
		arg.ID,
		arg.Title,
		arg.Difficulty,
		arg.Evaluator,
		arg.LockID,
		arg.LastUpdatedBy,
	)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Difficulty,
		&i.Evaluator,
		&i.LockID,
		&i.CreatedBy,
		&i.LastUpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateStandardProblemData = `-- name: UpdateStandardProblemData :one
UPDATE standard_problem_data
SET
    statement = $2,
    input_format = $3,
    output_format = $4,
    function_definitons = $5,
    example_testcases = $6,
    notes = $7,
    memory_limit_kb = $8,
    time_limit_ms = $9,
    submission_link = $10,
    last_updated_by = $11
WHERE
    problem_id = $1
RETURNING problem_id, statement, input_format, output_format, function_definitons, example_testcases, notes, memory_limit_kb, time_limit_ms, submission_link, last_updated_by
`

type UpdateStandardProblemDataParams struct {
	ProblemID          int32            `json:"problem_id"`
	Statement          string           `json:"statement"`
	InputFormat        string           `json:"input_format"`
	OutputFormat       string           `json:"output_format"`
	FunctionDefinitons *json.RawMessage `json:"function_definitons"`
	ExampleTestcases   *json.RawMessage `json:"example_testcases"`
	Notes              *string          `json:"notes"`
	MemoryLimitKb      int32            `json:"memory_limit_kb"`
	TimeLimitMs        int32            `json:"time_limit_ms"`
	SubmissionLink     *string          `json:"submission_link"`
	LastUpdatedBy      uuid.UUID        `json:"last_updated_by"`
}

func (q *Queries) UpdateStandardProblemData(ctx context.Context, arg UpdateStandardProblemDataParams) (StandardProblemDatum, error) {
	row := q.db.QueryRow(ctx, updateStandardProblemData,
		arg.ProblemID,
		arg.Statement,
		arg.InputFormat,
		arg.OutputFormat,
		arg.FunctionDefinitons,
		arg.ExampleTestcases,
		arg.Notes,
		arg.MemoryLimitKb,
		arg.TimeLimitMs,
		arg.SubmissionLink,
		arg.LastUpdatedBy,
	)
	var i StandardProblemDatum
	err := row.Scan(
		&i.ProblemID,
		&i.Statement,
		&i.InputFormat,
		&i.OutputFormat,
		&i.FunctionDefinitons,
		&i.ExampleTestcases,
		&i.Notes,
		&i.MemoryLimitKb,
		&i.TimeLimitMs,
		&i.SubmissionLink,
		&i.LastUpdatedBy,
	)
	return i, err
}
