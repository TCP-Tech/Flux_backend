// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: problems.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const addProblem = `-- name: AddProblem :one
INSERT INTO problems (
    title,
    statement,
    input_format,
    output_format,
    example_testcases,
    notes,
    memory_limit_kb,
    time_limit_ms,
    created_by,
    last_updated_by,
    difficulty,
    submission_link,
    platform
) VALUES (
    $1, -- title
    $2, -- statement
    $3, -- input_format (can be NULL)
    $4, -- output_format (can be NULL)
    $5, -- samples (can be NULL)
    $6, -- notes (can be NULL)
    $7, -- memory_limit_kb
    $8, -- time_limit_ms
    $9, -- created_by (UUID)
    $9, -- last_updated_by (UUID)
    $10, -- difficulty (can be NULL)
    $11, -- submission_link (can be NULL)
    $12  -- platform (can be NULL)
)
RETURNING id, created_at, updated_at
`

type AddProblemParams struct {
	Title            string                `json:"title"`
	Statement        string                `json:"statement"`
	InputFormat      string                `json:"input_format"`
	OutputFormat     string                `json:"output_format"`
	ExampleTestcases pqtype.NullRawMessage `json:"example_testcases"`
	Notes            sql.NullString        `json:"notes"`
	MemoryLimitKb    int32                 `json:"memory_limit_kb"`
	TimeLimitMs      int32                 `json:"time_limit_ms"`
	CreatedBy        uuid.UUID             `json:"created_by"`
	Difficulty       int32                 `json:"difficulty"`
	SubmissionLink   sql.NullString        `json:"submission_link"`
	Platform         NullPlatformType      `json:"platform"`
}

type AddProblemRow struct {
	ID        int32     `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) AddProblem(ctx context.Context, arg AddProblemParams) (AddProblemRow, error) {
	row := q.db.QueryRowContext(ctx, addProblem,
		arg.Title,
		arg.Statement,
		arg.InputFormat,
		arg.OutputFormat,
		arg.ExampleTestcases,
		arg.Notes,
		arg.MemoryLimitKb,
		arg.TimeLimitMs,
		arg.CreatedBy,
		arg.Difficulty,
		arg.SubmissionLink,
		arg.Platform,
	)
	var i AddProblemRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const checkPlatformType = `-- name: CheckPlatformType :one
SELECT $1::platform_type
`

func (q *Queries) CheckPlatformType(ctx context.Context, dollar_1 string) (string, error) {
	row := q.db.QueryRowContext(ctx, checkPlatformType, dollar_1)
	var column_1 string
	err := row.Scan(&column_1)
	return column_1, err
}

const createLock = `-- name: CreateLock :one
INSERT INTO locks (timeout) VALUES ($1)
RETURNING id, timeout, access
`

func (q *Queries) CreateLock(ctx context.Context, timeout time.Time) (Lock, error) {
	row := q.db.QueryRowContext(ctx, createLock, timeout)
	var i Lock
	err := row.Scan(&i.ID, &i.Timeout, &i.Access)
	return i, err
}

const getProblemById = `-- name: GetProblemById :one
SELECT id, title, statement, input_format, output_format, example_testcases, notes, memory_limit_kb, time_limit_ms, created_by, last_updated_by, created_at, updated_at, difficulty, submission_link, platform, lock_id FROM problems WHERE id = $1
`

func (q *Queries) GetProblemById(ctx context.Context, id int32) (Problem, error) {
	row := q.db.QueryRowContext(ctx, getProblemById, id)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Statement,
		&i.InputFormat,
		&i.OutputFormat,
		&i.ExampleTestcases,
		&i.Notes,
		&i.MemoryLimitKb,
		&i.TimeLimitMs,
		&i.CreatedBy,
		&i.LastUpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Difficulty,
		&i.SubmissionLink,
		&i.Platform,
		&i.LockID,
	)
	return i, err
}

const listProblemsWithPagination = `-- name: ListProblemsWithPagination :many
SELECT id, title, statement, input_format, output_format, example_testcases, notes, memory_limit_kb, time_limit_ms, created_by, last_updated_by, created_at, updated_at, difficulty, submission_link, platform, lock_id FROM problems
WHERE
    title ILIKE $1 AND
    (
        $4::uuid IS NULL OR
        created_by = $4::uuid OR
        last_updated_by = $4::uuid
    )
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListProblemsWithPaginationParams struct {
	Title    string        `json:"title"`
	Limit    int32         `json:"limit"`
	Offset   int32         `json:"offset"`
	AuthorID uuid.NullUUID `json:"author_id"`
}

func (q *Queries) ListProblemsWithPagination(ctx context.Context, arg ListProblemsWithPaginationParams) ([]Problem, error) {
	rows, err := q.db.QueryContext(ctx, listProblemsWithPagination,
		arg.Title,
		arg.Limit,
		arg.Offset,
		arg.AuthorID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Problem
	for rows.Next() {
		var i Problem
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Statement,
			&i.InputFormat,
			&i.OutputFormat,
			&i.ExampleTestcases,
			&i.Notes,
			&i.MemoryLimitKb,
			&i.TimeLimitMs,
			&i.CreatedBy,
			&i.LastUpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Difficulty,
			&i.SubmissionLink,
			&i.Platform,
			&i.LockID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProblem = `-- name: UpdateProblem :one
UPDATE problems
SET
    title = $1,
    statement = $2,
    input_format = $3,
    output_format = $4,
    example_testcases = $5,
    notes = $6,
    memory_limit_kb = $7,
    time_limit_ms = $8,
    difficulty = $9,
    submission_link = $10,
    platform = $11,
    last_updated_by = $12
WHERE
    id = $13
RETURNING id, title, statement, input_format, output_format, example_testcases, notes, memory_limit_kb, time_limit_ms, created_by, last_updated_by, created_at, updated_at, difficulty, submission_link, platform, lock_id
`

type UpdateProblemParams struct {
	Title            string                `json:"title"`
	Statement        string                `json:"statement"`
	InputFormat      string                `json:"input_format"`
	OutputFormat     string                `json:"output_format"`
	ExampleTestcases pqtype.NullRawMessage `json:"example_testcases"`
	Notes            sql.NullString        `json:"notes"`
	MemoryLimitKb    int32                 `json:"memory_limit_kb"`
	TimeLimitMs      int32                 `json:"time_limit_ms"`
	Difficulty       int32                 `json:"difficulty"`
	SubmissionLink   sql.NullString        `json:"submission_link"`
	Platform         NullPlatformType      `json:"platform"`
	LastUpdatedBy    uuid.UUID             `json:"last_updated_by"`
	ID               int32                 `json:"id"`
}

func (q *Queries) UpdateProblem(ctx context.Context, arg UpdateProblemParams) (Problem, error) {
	row := q.db.QueryRowContext(ctx, updateProblem,
		arg.Title,
		arg.Statement,
		arg.InputFormat,
		arg.OutputFormat,
		arg.ExampleTestcases,
		arg.Notes,
		arg.MemoryLimitKb,
		arg.TimeLimitMs,
		arg.Difficulty,
		arg.SubmissionLink,
		arg.Platform,
		arg.LastUpdatedBy,
		arg.ID,
	)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Statement,
		&i.InputFormat,
		&i.OutputFormat,
		&i.ExampleTestcases,
		&i.Notes,
		&i.MemoryLimitKb,
		&i.TimeLimitMs,
		&i.CreatedBy,
		&i.LastUpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Difficulty,
		&i.SubmissionLink,
		&i.Platform,
		&i.LockID,
	)
	return i, err
}
