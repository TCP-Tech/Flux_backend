// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package database

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
)

type LockType string

const (
	LockTypeManual LockType = "manual"
	LockTypeTimer  LockType = "timer"
)

func (e *LockType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LockType(s)
	case string:
		*e = LockType(s)
	default:
		return fmt.Errorf("unsupported scan type for LockType: %T", src)
	}
	return nil
}

type NullLockType struct {
	LockType LockType `json:"lock_type"`
	Valid    bool     `json:"valid"` // Valid is true if LockType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLockType) Scan(value interface{}) error {
	if value == nil {
		ns.LockType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LockType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLockType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LockType), nil
}

type Bot struct {
	ID          uuid.UUID        `json:"id"`
	AccountName string           `json:"account_name"`
	Platform    string           `json:"platform"`
	WebsiteData *json.RawMessage `json:"website_data"`
	CreatedAt   time.Time        `json:"created_at"`
	UpdatedAt   time.Time        `json:"updated_at"`
}

type Contest struct {
	ID          uuid.UUID  `json:"id"`
	Title       string     `json:"title"`
	CreatedBy   uuid.UUID  `json:"created_by"`
	CreatedAt   time.Time  `json:"created_at"`
	UpdatedAt   time.Time  `json:"updated_at"`
	StartTime   *time.Time `json:"start_time"`
	EndTime     time.Time  `json:"end_time"`
	IsPublished bool       `json:"is_published"`
	LockID      *uuid.UUID `json:"lock_id"`
}

type ContestProblem struct {
	ContestID uuid.UUID `json:"contest_id"`
	ProblemID int32     `json:"problem_id"`
	Score     int32     `json:"score"`
}

type ContestRegisteredUser struct {
	UserID    uuid.UUID `json:"user_id"`
	ContestID uuid.UUID `json:"contest_id"`
}

type Lock struct {
	ID          uuid.UUID  `json:"id"`
	Name        string     `json:"name"`
	CreatedBy   uuid.UUID  `json:"created_by"`
	CreatedAt   time.Time  `json:"created_at"`
	Description string     `json:"description"`
	Access      string     `json:"access"`
	LockType    LockType   `json:"lock_type"`
	Timeout     *time.Time `json:"timeout"`
}

type Problem struct {
	ID            int32      `json:"id"`
	Title         string     `json:"title"`
	Difficulty    int32      `json:"difficulty"`
	Evaluator     string     `json:"evaluator"`
	LockID        *uuid.UUID `json:"lock_id"`
	CreatedBy     uuid.UUID  `json:"created_by"`
	LastUpdatedBy uuid.UUID  `json:"last_updated_by"`
	CreatedAt     time.Time  `json:"created_at"`
	UpdatedAt     time.Time  `json:"updated_at"`
}

type Role struct {
	RoleName string `json:"role_name"`
}

type Solved struct {
	UserID    uuid.UUID `json:"user_id"`
	ContestID uuid.UUID `json:"contest_id"`
	ProblemID uuid.UUID `json:"problem_id"`
}

type StandardProblemDatum struct {
	ProblemID          int32            `json:"problem_id"`
	Statement          string           `json:"statement"`
	InputFormat        string           `json:"input_format"`
	OutputFormat       string           `json:"output_format"`
	FunctionDefinitons *json.RawMessage `json:"function_definitons"`
	ExampleTestcases   *json.RawMessage `json:"example_testcases"`
	Notes              *string          `json:"notes"`
	MemoryLimitKb      int32            `json:"memory_limit_kb"`
	TimeLimitMs        int32            `json:"time_limit_ms"`
	SubmissionLink     *string          `json:"submission_link"`
	LastUpdatedBy      uuid.UUID        `json:"last_updated_by"`
}

type Submission struct {
	ID          uuid.UUID       `json:"id"`
	SubmittedBy uuid.UUID       `json:"submitted_by"`
	ContestID   *uuid.UUID      `json:"contest_id"`
	ProblemID   int32           `json:"problem_id"`
	Solution    json.RawMessage `json:"solution"`
	State       string          `json:"state"`
	SubmittedAt time.Time       `json:"submitted_at"`
	UpdatedAt   time.Time       `json:"updated_at"`
}

type Token struct {
	ID          uuid.UUID       `json:"id"`
	HashedToken string          `json:"hashed_token"`
	Purpose     string          `json:"purpose"`
	Payload     json.RawMessage `json:"payload"`
	Email       string          `json:"email"`
	ExpiresAt   time.Time       `json:"expires_at"`
	CreatedAt   time.Time       `json:"created_at"`
}

type Tournament struct {
	ID          uuid.UUID `json:"id"`
	Title       string    `json:"title"`
	IsPublished bool      `json:"is_published"`
	CreatedBy   uuid.UUID `json:"created_by"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

type TournamentContest struct {
	RoundID   uuid.UUID `json:"round_id"`
	ContestID uuid.UUID `json:"contest_id"`
}

type TournamentRound struct {
	ID           uuid.UUID  `json:"id"`
	TournamentID uuid.UUID  `json:"tournament_id"`
	RoundNumber  int32      `json:"round_number"`
	Title        string     `json:"title"`
	LockID       *uuid.UUID `json:"lock_id"`
	CreatedBy    uuid.UUID  `json:"created_by"`
	UpdatedAt    time.Time  `json:"updated_at"`
}

type User struct {
	ID           uuid.UUID `json:"id"`
	RollNo       string    `json:"roll_no"`
	UserName     string    `json:"user_name"`
	FirstName    string    `json:"first_name"`
	LastName     string    `json:"last_name"`
	Email        string    `json:"email"`
	PasswordHash string    `json:"password_hash"`
	CreatedAt    time.Time `json:"created_at"`
}

type UserRole struct {
	UserID   uuid.UUID `json:"user_id"`
	RoleName string    `json:"role_name"`
}

type UserScore struct {
	UserID       uuid.UUID `json:"user_id"`
	ContestID    uuid.UUID `json:"contest_id"`
	ProblemID    uuid.UUID `json:"problem_id"`
	Score        int32     `json:"score"`
	UpdatedAt    time.Time `json:"updated_at"`
	SubmissionID uuid.UUID `json:"submission_id"`
}
